<!--basic algos and DS -->
<!--muveletigen,  bestcase,worst case, average case
    memoriahasznalat,
    peldak : mire hol hasznaljak, javaban mi hogy van megvalositva

    TODO :
    - add : tries etc  - from geeks
    - variacio, konbinacio, permutacio, hatv halmaz  - bevesznemvesz + leggyorsabb algo
    - errol eloszor exel : adatszerk : abs - impl - impl javaban, build/init, delete, bovites, csokkentes, alapmuv : insert,delete, read/w
    - backtracking : general solution
    - basic math : osszegyujteni - furmulak becslesek : princeton link , hackers delight ....
    - bitmanipulation : osszegyujteni

    -->
<questionlist>
    <tetel>
        <question>
            quicksort - muveletigeny(best,worst,avg), mem. hasznalat
            mikor hol, javaban hogy implementalva
        </question>
        <answer>
            time complex : n * logn
            space complex ( total amount of memory ): helyben rendez

            invarians i -re : i. elemig m√°r jo, kisebb mint pivot, (i + 1) lehet kisebb is nagyobb is mint pivot


            int partition(int arr[],int low,int high)
            {
                int pivot=arr[high];
                int i=(low-1);

                for(int j=low;j less or eq. high;j++)
                {
                    if(arr[j] less pivot)
                    {
                        i++;
                        swap(arr[i],arr[j]);
                    }
                }
                swap(arr[i+1],arr[high]);
                return (i+1);
            }

        </answer>
        <links>https://www.geeksforgeeks.org/quick-sort/</links>
    </tetel>
    <tetel>
        <question>
            mergesort - muveletigeny(best,worst,avg), mem. hasznalat
            mikor hol, javaban hogy implementalva
        </question>
        <answer>

        </answer>
    </tetel>
    <tetel>
        <question>
            binarysearch - array, in the java mem. model
        </question>
        <answer>
        </answer>
    </tetel>
    <tetel>
        <question>
            bin tree - create, insert, search, save, load, copy
            traversal : pre, in, post
        </question>
        <answer>
            save : inorder,preorder, array - bintree
            load/build : array , in + post, pre + post, in + pre
        </answer>
    </tetel>
    <tetel>
        <question>
            bintree - szelessegi kereses , melysegi kereses
        </question>
        <answer>
        </answer>
    </tetel>
    <tetel>
        <question>
            heap - kupac
        </question>
        <answer>
        </answer>
    </tetel>
    <tetel>
        <question>
            tries
        </question>
        <links>https://en.wikipedia.org/wiki/Trie</links>
        <answer>
            valami valasz
        </answer>
    </tetel>
    <tetel>
        <question>
            binary search tree
        </question>
        <links>https://www.geeksforgeeks.org/binary-search-tree-data-structure/</links>
        <answer>

        </answer>
    </tetel>

    <tetel>
        <question>
            AVL tree
        </question>
        <links>https://en.wikipedia.org/wiki/AVL_tree</links>
        <answer>
            forgatasok : rotate_left, rotate_right, rotate_left_right, rotate_right_left

            muvetek : insert logN, delete logN

            After this insertion, if a tree becomes unbalanced, only ancestors of the newly inserted node are
            unbalanced. This is because only those nodes have their sub-trees altered.[13] So it is necessary
            to check each of the node's ancestors for consistency with the invariants of AVL trees: this is called
            "retracing". This is achieved by considering the balance factor of each node.

        </answer>
    </tetel>
    <tetel>
        <question>
            N-ary tree
        </question>
        <links>https://www.geeksforgeeks.org/generic-treesn-array-trees/</links>
        <answer>

        </answer>
    </tetel>
    <tetel>
        <question>
            basic data structures - how it is implemented in java
             pqueue, vector/arrayList
        </question>
        <answer>
        </answer>
    </tetel>
    <tetel>
        <question>
            basic data structures - how is implemented in java
            stack, queue,  hashtable
        </question>
        <answer>
        </answer>
    </tetel>
    <tetel>
        <question>
            dijkstra
        </question>
        <answer>
        </answer>
    </tetel>
    <tetel>
        <question>
            graf - szelessegi, melysegi bejaras
        </question>
        <answer>
        </answer>
    </tetel>
    <tetel>
        <question>
            time complexity, space complexity, aux space complexity
            peldak
        </question>
        <answer>
            time complexity:
            O : 1, logn, n, n*logn, n2, 2^n, n!

            auxiliary space : extra space used to do the alg.
            space complexity : input data space + auxiliary space

            O(1) space complexity : kb :  a bemenet novelesevel nem valtozik a szukseges hely, konstans
                extra helyet hasznalunk fel.

            pl O(1) : Y intersect list : first get listlengths es hosszabbat leszamlalva eslo azonos node
               nem O(1) : stackbe v hashmapbe tenni az elemeket

        </answer>
        <links>https://stackoverflow.com/questions/43260889/what-is-o1-space-complexity</links><ln>space complexity</ln>
        <links>https://www.geeksforgeeks.org/what-is-the-difference-between-auxiliary-space-and-space-complexity/</links><ln>GFG space complexity</ln>
    </tetel>
    <tetel>
        <question>
            graf - szinezes
        </question>
        <answer>
            negyszin tetel
        </answer>
    </tetel>
</questionlist>